# 3D Muscle Model Communication Architecture

This document describes how the 3D Muscle Model application communicates with the backend.

## Hybrid Communication Approach

The application uses a hybrid approach for communication with the backend:

1. **Socket.io** - Used for model control events (muscle highlighting, camera positioning)
2. **Server-Sent Events (SSE)** - Used for streaming LLM tokens in the chat interface

## Communication Flow

### Model Control Events (Socket.io)

Model control events (like highlighting muscles, changing camera angles, etc.) are handled through Socket.io:

```javascript
// Receiving model events from backend
socket.on('model_event', (data) => {
  switch (data.type) {
    case 'model:selectMuscles':
      // Handle muscle selection
      break;
    case 'model:setCameraView':
      // Handle camera view changes
      break;
    // ... other event types
  }
});
```

### Chat Token Streaming (SSE)

For chat message streaming, we use a hybrid approach:

1. Notify the backend via Socket.io that we're starting a conversation
2. Stream tokens via Server-Sent Events (SSE)

```javascript
// 1. Notify via Socket.io
socket.emit('model_start', {
  message: userMessage,
  thread_id: threadId,
  user_id: userId
});

// 2. Set up EventSource for token streaming
const params = new URLSearchParams({
  message: userMessage,
  thread_id: threadId,
  user_id: userId
});

const eventSource = new EventSource(`/model/token-stream?${params}`);
```

#### SSE Event Types

The Server-Sent Events endpoint emits several event types:

1. `metadata` - Initial metadata about the conversation (thread ID, etc.)
   ```javascript
   eventSource.addEventListener('metadata', (event) => {
     const data = JSON.parse(event.data);
     // Store metadata
   });
   ```

2. `thinking` - Indicates the model is thinking/processing
   ```javascript
   eventSource.addEventListener('thinking', (event) => {
     const data = JSON.parse(event.data);
     // Show thinking indicator
   });
   ```

3. `token` - Individual tokens as they are generated by the LLM
   ```javascript
   eventSource.addEventListener('token', (event) => {
     const data = JSON.parse(event.data);
     if (data.content) {
       // Update UI with each token
     }
   });
   ```

4. `complete` - The full response when complete
   ```javascript
   eventSource.addEventListener('complete', (event) => {
     const data = JSON.parse(event.data);
     if (data.response) {
       // Update with complete response
     }
   });
   ```

5. `event` - Model control events sent via SSE
   ```javascript
   eventSource.addEventListener('event', (event) => {
     const data = JSON.parse(event.data);
     // Process model events
   });
   ```

6. `done` - Marks completion of the stream
   ```javascript
   eventSource.addEventListener('done', () => {
     eventSource.close();
     // Finalize the message
   });
   ```

7. `error` - Error handling
   ```javascript
   eventSource.addEventListener('error', (error) => {
     eventSource.close();
     // Handle error state
   });
   ```

## Backward Compatibility

The system maintains backward compatibility with the old non-streaming approach through Socket.io event handlers. The `model_response` socket event is still supported for backward compatibility. 